#!/usr/bin/env python2
import sh
import os
import re
import sys
import json
import logging
from glob import glob
from os.path import join, exists, abspath, expanduser, realpath, dirname
from argparse import ArgumentParser, Namespace
from atom.api import Atom, Dict, List, Unicode, Instance, set_default
from contextlib import contextmanager
from collections import OrderedDict

@contextmanager
def cd(newdir):
    prevdir = os.getcwd()
    os.chdir(os.path.expanduser(newdir))
    try:
        print("Entering into {}".format(newdir))
        yield
        print("Returning to {}".format(prevdir))
    finally:
        os.chdir(prevdir)

#: Hack...
p4a_root = join(dirname(realpath(__file__)),'python-for-android')
p4i_root = join(dirname(realpath(__file__)),'python-for-ios')

sys.path.append(p4a_root)
from pythonforandroid.logger import shprint


class Command(Atom):
    title = Unicode()
    desc = Unicode()
    help = Unicode()
    ctx = Dict()
    cmds = Dict()
    args = List(tuple)
    parser = Instance(ArgumentParser)

    def run(self, args):
        pass


class Init(Command):
    title = set_default('init')
    help = set_default("Start a new enaml-native project")
    args = set_default([
        ('name',dict(help="Project name")),
        ('bundle_id',dict(help="App bundleId")),
        ('destination', dict(help="Project destination folder")),
        #('-t --template', dict(dest='template', action='store_const',help="Project destination folder")),
    ])

    def run(self, args):
        dest = abspath(args.destination)
        assert not exists(dest), "Error: Destination folder already exists! ({})".format(dest)
        root = dirname(realpath(__file__))

        #: Clean root android project
        with cd(root):
            self.cmds['clean-android'].run()

        #: Make project dir
        os.makedirs(dest)
        with cd(args.destination):
            #: Copy everything
            #: TODO: Should clean build first
            for f in ['android', 'ios', 'src', 'package.json']:
                shprint(sh.cp, '-R', join(root, f), '.')

            #: TODO: Make a readme

            #: Make simlink to enaml-native
            shprint(sh.ln, '-s' ,join(root, 'enaml-native'), 'enaml-native')

            #: Patch package
            with open('package.json') as f:
                pkg = json.load(f,object_pairs_hook=OrderedDict)
            pkg['name'] = args.name
            pkg['version'] = "1.0"
            pkg['bundle_id'] = args.bundle_id
            with open('package.json', 'w') as f:
                json.dump(pkg, f, indent=4)

            #: Patch android
            #: This is a hack haha
            with cd('android/app/'):
                build_gradle = []
                with open("build.gradle") as f:
                    lines = f.read().split("\n")

                for line in lines:
                    if re.match(r'\s+applicationId\s+".+"', line):
                        line = '        applicationId "{}"'.format(args.bundle_id)
                    elif re.match(r'\s+versionCode\s+\d+', line):
                        line = '        versionCode 1'
                    elif re.match(r'\s+versionName\s+".+"', line):
                        line = '        versionName "1.0"'
                    build_gradle.append(line)

                with open("build.gradle", 'w') as f:
                    f.write('\n'.join(build_gradle))

                with cd("src/main/"):
                    for src in ['AndroidManifest.xml',
                                'java/com/enaml/MainActivity.java']:
                        with open(src) as f:
                            data = f.read()
                        with open(src, 'w') as f:
                            f.write(data.replace("com.frmdstryr.enamlnative.demo",args.bundle_id))

                    with cd("res/values/"):
                        with open("strings.xml") as f:
                            data = f.read()
                        with open("strings.xml", "w") as f:
                            f.write(data.replace(
                                '<string name="app_name">Enaml-Native Demo</string>',
                                '<string name="app_name">{}</string>'.format(args.name)
                            ))

        #: Init VCS
        shprint(sh.git,'init')


class CleanPython(Command):
    title = set_default("clean-python")
    help = set_default("Remove python-for-android build and .so libs")
    args = set_default([
        ('-a', dict(action='store_true', help="Clean all")),
        ('--ios',dict(action='store_true', help="Clean iOS only")),
        ('--android',dict(action='store_true', help="Clean android only")),
    ])

    def run(self, args=None):
        ctx = self.ctx

        if args is None or not args.ios:
            with cd(ctx['android']['p4a']):
                if args and args.a:
                    shprint(sh.python, 'p4a.py', 'clean_all')
                    #for arch in ctx['arches']:
                    #    #: Clean so
                    #    shprint(sh.rm, '-R', 'android/app/src/main/libs/{}/'.format(arch))
                else:
                    shprint(sh.python, 'p4a.py', 'clean_dists')
                    shprint(sh.python, 'p4a.py', 'clean_builds')
        if args is None or not args.android:
            if args and args.a: #: Only for clean all, building takes FOREVER
                with cd(ctx['ios']['p4i']):
                    recipes = []
                    for line in sh.python('toolchain.py','status').stdout.split("\n"):
                        print(line)
                        if line.split("-")[-1].strip().lower()=="not built":
                            continue
                        recipes.append(line.split(" ")[0])
                    print("Cleaning {}".format(recipes))
                    for r in recipes:
                        shprint(sh.python,'toolchain.py','clean',r)

class NdkBuild(Command):
    title = set_default("ndk-build")
    help = set_default("Run ndk-build on the android project")

    def run(self, args=None):
        ctx = self.ctx
        ndk_build = sh.Command(join(ctx['android']['ndk'], 'ndk-build'))
        arches = ctx['android']['arches']
        with cd('android/app/src/main/jni'):

            #: Patch Applicaiton.mk to have the correct ABI's
            with open('Application.mk') as f:
                app_mk = f.read()

            #: APP_ABI := armeabi-v7a
            new_mk = []
            for line in app_mk.split("\n"):
                if re.match(r'APP_ABI\s*:=\s*.+', line):
                    line = 'APP_ABI := {}'.format(" ".join(arches))
                new_mk.append(line)

            with open('Application.mk','w') as f:
                f.write("\n".join(new_mk))

            #: Now run nkd-build
            shprint(ndk_build)


class CrossCompile(Command):
    title = set_default("cross-compile")
    help = set_default("Build the python requirements for ios")

    def run(self, args=None):
        import crosscompile
        from crosscompile.recipe import Platform,Arch
        b = crosscompile.Builder(
            requirements=[
                crosscompile.recipes.openssl.Recipe,
            ],
            platforms=[
                    Platform(name='macOS',arches=[
                        Arch(name='macosx.x86_64'),
                    ]),
                    Platform(name='iOS',arches=[
                        Arch(name='iphonesimulator.x86_64'),
                        Arch(name='iphonesimulator.i386'),
                        Arch(name='iphoneos.armv7'),
                        Arch(name='iphoneos.armv7s'),
                        Arch(name='iphoneos.armv64'),
                    ]),
                    Platform(name='tvOS',arches=[
                        Arch(name='appletvsimulator.x86_64'),
                        Arch(name='appletvos.arm64'),
                    ]),
                    Platform(name='watchOS',arches=[
                        Arch(name='watchsimulator.i386'),
                        Arch(name='watchos.armv7k'),
                    ]),
                ],

        )
        b.build()



class BuildPython(Command):
    """ Builds an enaml-native python app using the following steps:

        For Android:
        1. Runs ndk-build to build JNI modules
        2. Run p4a apk to build python requirements for each arch
            and copies them to the lib a local folder
        3. Pull all so files from site-packages and rename to lib.pkg.to.so
            and place them in the lib/<arch> folder

        For iOS:
        1. Run p4i toolchain build <req>
    """
    title = set_default("build-python")
    help = set_default("Build the python requirements")
    args = set_default([
        ('-d', dict(action='store_true', help="Print full debug log")),
        ('--ios', dict(action='store_true', help="iOS only")),
        ('--android', dict(action='store_true', help="Android only")),
    ])

    def run(self, args=None):
        if args is None or not args.ios:
            self.run_android(args)
        if args is None or not args.android:
            self.run_ios(args)

        #: Extra cleanup
        self.cmds['trim-assets'].run()

    def run_android(self,args):
        ctx = self.ctx
        env = ctx['android']
        reqs = ",".join(env['dependencies'].keys())

        #: Run ndk build
        #: Um, we're passing args from another command?
        self.cmds['ndk-build'].run(args)

        #: Build for each arch
        for arch in env['arches']:
            cfg = dict(
               arch=arch,
               reqs=reqs,
               bundle_id=ctx['bundle_id']
            )
            cfg.update(env)

            #: Um, we're passing args from another command?
            #: Clean whatever build from previous arch
            self.cmds['clean-python'].run()

            #: Add debug arg if needed
            cfg['debug'] = '--debug ' if args.d else ''
            if args.d:
                logger = logging.getLogger('p4a')
                logger.level = logging.DEBUG

            with cd(ctx['android']['p4a']):
                shprint(sh.python,*'p4a.py apk --arch={arch} '
                          '--private=../src '
                          '--package={} '
                          '--name=EnamlNativeApplication '
                          '--dist-name=enaml-native '
                          '--version=0.1 '
                          '--requirements={reqs} '
                          '--android-api=25 '
                          '--bootstrap=enaml '
                          '--sdk-dir={sdk} '
                          '--ndk-dir={ndk} '
                          '--ndk-platform=21 '
                          '{debug}'
                          '--copy-libs'.format(**cfg).split(' '))

            #: Copy lib folder
            shprint(sh.cp,'-R',
                  expanduser('~/.local/share/python-for-android/dists/enaml-native/libs/{arch}'.format(**cfg)),
                  'android/app/src/main/libs')

            #: Copy modules
            for f in ['modules', 'site-packages']:
                shprint(sh.cp,'-R',
                      expanduser('~/.local/share/python-for-android/dists/enaml-native/python/{}'.format(f)),
                      'android/app/src/main/python/{arch}'.format(**cfg))

            #: Copy ca-cert
            with cd('android/app/src/main/python/{arch}/site-packages/tornado/'.format(**cfg)):
                shprint(sh.cp, '/etc/ssl/certs/ca-certificates.crt', '.')

            #: Where .so files go
            dst = abspath('android/app/src/main/libs/{arch}'.format(**cfg))

            #: Collect all .so files and rename them
            with cd('android/app/src/main/python/{arch}'.format(**cfg)):
                for mod in sh.find('.','-name', '*.so').stdout.strip().split("\n"):
                    #: Strip ./modules or ./site-packages
                    pgk = ".".join(['lib']+mod.split("/")[2:])
                    #: Rename mod.so to pkg.mod.so and move to libs
                    shprint(sh.mv,mod, join(dst, pgk))

    def run_ios(self,args):
        ctx = self.ctx
        env = ctx['ios']
        #: Replace crystax with just python on ios
        reqs = env['dependencies'].keys()

        with cd('python-for-ios'):
            shprint(sh.python,'toolchain.py','build',*reqs)


class TrimAssets(Command):
    title = set_default("trim-assets")
    help = set_default("Trim away unused files from the python install for each arch")

    def run(self, args=None):
        ctx = self.ctx

        #: Clean each arch
        for arch in ctx['android']['arches']:
            with cd('android/app/src/main/python/{arch}/site-packages/'.format(arch=arch)):
                shprint(sh.find,'.','-type','f','-name','*.py','-delete')
                shprint(sh.find,'.','-type','f','-name','*.pyc','-delete')
                #shprint(sh.find,'.','-type','f','-name','*.pyo','-delete') #: Use pyo
                for p in [
                            'enaml/qt',
                            'tornado/test',
                            '*.egg-info',
                            '*.dist-info',
                            'tests',
                            'usr',
                          ]:
                    try:
                        sh.rm('-R', *glob(p))
                    except:
                        pass


class BundleAssets(Command):
    """ This is used by the gradle build to pack python into a zip.
    """
    title = set_default("bundle-assets")
    help = set_default("Creates a python.zip bundle of all py files")
    args = set_default([
        ('-p', dict(action='store_true', help="Create bundle by pulling from device "
                                             "(recommended for release, includes generated cache files)")),
    ])

    def run(self, args=None):
        ctx = self.ctx
        env = ctx['android']
        #: Clean each arch
        for arch in env['arches']:
            #: Remove old
            cfg = dict(arch=arch,bundle_id=ctx['bundle_id'])
            cfg.update(env)
            root = abspath(os.getcwd())
            with cd('android/app/src/main/python/'):
                #: Remove old build
                if os.path.exists('build'):
                    shprint(sh.rm, '-R', 'build')

                if args and args.p:
                    #: Restart as root
                    shprint(sh.adb, 'root')

                    #: Pull assets and cache from device
                    shprint(sh.adb, 'pull',
                            '/data/user/0/{bundle_id}/assets/python/'.format(**cfg),
                            'build')
                else:
                    #: Extract stdlib.zip to build/
                    shprint(sh.mkdir,'build')

                    with cd('build'):
                        shprint(sh.unzip,
                                '{ndk}/sources/python/2.7/libs/{arch}/stdlib.zip'.format(**cfg),
                                '-d', 'stdlib')

                        #: Copy site-packages to build/
                    with cd('{arch}/site-packages/'.format(**cfg)):
                        shprint(sh.cp, '-R', '.', '../../build/site-packages')

                    #: Copy sources from app source
                    #: TODO, or just let gradle?
                    for src in ctx['sources']:
                        shprint(sh.cp, '-R', join(root, src, '.'), 'build')

                #: Remove old
                if os.path.exists('python.zip'):
                    shprint(sh.rm, 'python.zip')

                #: Zip everything and copy to assets arch to build
                with cd('build'):
                    #shprint(sh.zip, '-r', 'android/app/src/main/assets/python/python.zip', '.')
                    shprint(sh.zip, '-r', '../python.zip', '.')


            break #: They should all be the same so stop after the first

        #: Now copy to android assets folder
        shprint(sh.cp,
                'android/app/src/main/python/python.zip',
                'android/app/src/main/assets/python/python.zip')

        #: And wth, just copy it to the ios folder too :)
        shprint(sh.cp,
                'android/app/src/main/python/python.zip',
                'ios/App/Python/python.zip')
        #: Can iOS unpack this??

class AllPython(Command):
    title = set_default("all-python")
    help = set_default("Does clean, build, trim, and bundle")

    def run(self, args=None):
        for cmd in ['build-python',
                    'trim-assets',
                    'bundle-assets']:
            self.cmds[cmd].run()


class BuildAndroid(Command):
    title = set_default("build-android")
    help = set_default("Build android project")
    args = set_default([
        ('-r', dict(action='store_true', help="Release mode")),
    ])

    def run(self, args=None):
        with cd("android"):
            gradlew = sh.Command('./gradlew')
            if args.r:
                shprint(gradlew, 'assembleRelease')
            else:
                shprint(gradlew, 'assembleDebug')


class CleanAndroid(Command):
    title = set_default("clean-android")
    help = set_default("Clean the android project")

    def run(self, args=None):
        with cd('android'):
            gradlew = sh.Command('./gradlew')
            shprint(gradlew, 'clean')


class RunAndroid(Command):
    title = set_default("run-android")
    help = set_default("Build android project, install it, and run")

    def run(self, args=None):
        ctx = self.ctx
        bundle_id = ctx['bundle_id']
        with cd("android"):
            gradlew = sh.Command('./gradlew')

            #: If no devices are connected, start the simulator
            if len(sh.adb('devices').stdout.strip())==1:
                device = sh.emulator('-list-avds').stdout.split("\n")[0]
                shprint(sh.emulator, '-avd', device)

            shprint(gradlew, 'installDebug')
            shprint(sh.adb, 'shell', 'am', 'start', '-n',
                        '{}/com.enaml.MainActivity'.format(bundle_id))


class CleanIOS(Command):
    title = set_default("clean-ios")
    help = set_default("Clean the ios project")

    def run(self, args=None):
        with cd('ios'):
            shprint(sh.xcodebuild, 'clean', '-project', 'App.xcodeproj',
                    '-configuration', 'ReleaseAdhoc', '-alltargets')


class RunIOS(Command):
    title = set_default("run-ios")
    help = set_default("Build and run the ios project")
    # args = set_default([
    #     ('name',dict(help="Project name")),
    #     ('bundle_id',dict(help="App bundleId")),
    #     ('destination', dict(help="Project destination folder")),
    #     #('-t --template', dict(dest='template', action='store_const',help="Project destination folder")),
    # ])

    def run(self, args=None):
        ctx = self.ctx
        with cd('ios'):
            shprint(sh.xcrun, 'xcodebuild',
                    '-scheme', 'App',
                    '-project', 'App.xcodeproj',
                    '-configuration', 'Debug',
                    #'-destination', 'platform=iOS Simulator,name=iPhone 7 Plus,OS=10.2',
                    '-derivedDataPath',
                    'build')
            shprint(sh.xcrun, 'simctl', 'install', 'booted',
                    'build/Build/Products/Debug-iphonesimulator/App.app')
            shprint(sh.xcrun, 'simctl', 'launch', 'booted', ctx['bundle_id'])




def find_commands(cls):
    """ Finds commands by finding the subclasses of Command"""
    cmds = []
    for subclass in cls.__subclasses__():
        cmds.append(subclass)
        cmds.extend(find_commands(subclass))
    return cmds


class EnamlNativeCli(Atom):
    #: Root parser
    parser = Instance(ArgumentParser)

    #: Loaded from package
    ctx = Dict()

    #: Parsed args
    args = Instance(Namespace)

    #: Location of package file
    package = Unicode("package.json")

    #: Commands
    commands = List(Command)

    def _default_commands(self):
        return [c() for c in find_commands(Command)]

    def _default_parser(self):
        parser = ArgumentParser(prog='enaml-native')

        #: Build commands by name
        cmds = {c.title:c for c in self.commands}

        with open(self.package) as f:
            self.ctx = json.load(f)

        #: Hack.. Add p4a to ctx
        global p4a_root
        global p4i_root
        self.ctx['android']['p4a'] = p4a_root
        self.ctx['ios']['p4i'] = p4i_root

        #: Build parser, prepare commands
        subparsers = parser.add_subparsers()
        for c in self.commands:
            p = subparsers.add_parser(c.title, help=c.help)
            c.parser = p
            for (flags,kwargs) in c.args:
                p.add_argument(flags,**kwargs)
            p.set_defaults(cmd=c)
            c.ctx = self.ctx
            c.cmds = cmds

        return parser

    def start(self):
        """ Run the commands"""
        self.args = self.parser.parse_args()

        cmd = self.args.cmd
        try:
            cmd.run(self.args)
        except sh.ErrorReturnCode as e:
            print(e.stderr)
            print(e.stdout)
            raise



def main():
    EnamlNativeCli().start()

if __name__ == '__main__':
    main()